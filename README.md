# pattern
设计模式的学习
###1.单例模式：
1.饿汉单例模式在类加载时就创建对象，如果没用就占用内存 <br>
2.懒汉单例模式为了线程安全考虑要加锁，如果线程过多会阻塞，影响性能 <br>
3.静态内部类式的单例模式兼顾了饿汉模式的内存浪费，也兼顾了懒汉模式中的性能问题 <br>
4.以上几个都可以被反射和序列化破坏 <br>
5.反射破坏可以在构造方法中抛出异常来解决<br> 
6.序列化破坏可以重写ReadResolve方法来解决 <br>
7.除了以上几个还有注册式单例，其中一个就是枚举式单例，它是一种饿汉式单例，枚举式单例不能被反射和序列化破坏<br> 
8.还有一种容器式单例，但是它线程不安全，可以加锁 <br>
9.还可以用ThreadLocal实现单例，但是它只在这一个线程中为唯一<br>
<br>
###工厂模式 
#####1.简单工厂模式 
简单工厂模式不是23种设计模式中的任何一种，不符合开闭原则，只适用于创建较少的对象，但是易于理解。 <br>
#####2.工厂方法模式 
它是23种设计模式中的一种，创建一个对象的接口，在子类中实现类的实例化，主要解决扩展问题，但是它类更多，更抽象、复杂，难于理解 
#####3.抽象工厂模式 
它是23中设计模式中的一种，它需要一系列相互依赖或相关的接口，规定类所有可能被创建的产品，类更多，更抽象、复杂，难于理解，要扩展就需要增修改工厂接口，但是代码是人控的，可以长时间来维护修改升级一次<br>
<br>
###代理模式
1.静态代理不符合开闭原则，只能作用于特定的对象 <br>
2.jdk静态代理必须实现接口，底层是写一个类实现所有接口的方法，然后编译成字节码文件，来扩展方法，通过反射调用 <br>
3.cglib动态代理是生成一个继承于对象的类，然后通过调用对象来实现 <br>
4.在编译阶段jdk更快，调用阶段cgkib更快 <br>
5.spring中实现来接口的类采用jdk动态代理，没有实现的用cglib动态代理扩展类<br>
<br>
###原型模式 　　
1.原型模式允许在运行时动态改变具体的实现类型。原型模式可以在运行期间，由客户来注册符合原型接口的实现类型，也可以动态地改变具体的实现类型，看起来接口没有任何变化，但其实运行的已经是另外一个类实例了。因为克隆一个原型就类似于实例化一个类。<br>
2.原型模式最主要的缺点是每一个类都必须配备一个克隆方法。配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类来说不是很难，而对于已经有的类不一定很容易，特别是当一个类引用不支持序列化的间接对象，或者引用含有循环结构的时候<br>
<br>
###策略模式
1.策略模式符合开闭原则。<br>
2.避免使用多重条件转移语句，如 if...else...语句、switch 语句 <br>
3.使用策略模式可以提高算法的保密性和安全性。<br>
4.客户端.须知道所有的策略，并且自行决定使用哪一个策略类。 <br>
5.代码中会产生非常多策略类，增加维护难度。<br>


